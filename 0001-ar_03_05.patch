From 799b76c434d69bfd26bc8494d2d61100e32285d5 Mon Sep 17 00:00:00 2001
From: yangchengjian0101 <yangchengjian0101@gmail.com>
Date: Thu, 5 Mar 2020 20:33:41 +0800
Subject: [PATCH] ar_03_05

---
 components/canvas/Cargo.toml                       |   3 +
 components/canvas/webgl_thread.rs                  | 127 ++++++++++++++++++++-
 components/canvas_traits/webgl.rs                  |  13 +++
 components/script/dom/webgl2renderingcontext.rs    |  28 +++++
 components/script/dom/webglrenderingcontext.rs     |  55 +++++++++
 .../dom/webidls/WebGLRenderingContext.webidl       |   9 ++
 support/android/apk/servoapp/build.gradle          |   5 +
 .../apk/servoapp/src/main/AndroidManifest.xml      |   8 ++
 .../org/mozilla/servo/CameraPermissionHelper.java  |  55 +++++++++
 .../main/java/org/mozilla/servo/MainActivity.java  |   6 +
 10 files changed, 308 insertions(+), 1 deletion(-)
 create mode 100755 support/android/apk/servoapp/src/main/java/org/mozilla/servo/CameraPermissionHelper.java

diff --git a/components/canvas/Cargo.toml b/components/canvas/Cargo.toml
index 08c060e536..38e2adff3f 100644
--- a/components/canvas/Cargo.toml
+++ b/components/canvas/Cargo.toml
@@ -44,3 +44,6 @@ webxr-api = {git = "https://github.com/servo/webxr", features = ["ipc"]}
 surfman = { version = "0.1", features = ["sm-angle", "sm-osmesa"] }
 surfman-chains = "0.2"
 surfman-chains-api = "0.2"
+
+[target.'cfg(target_os = "android")'.dependencies]
+arcore_jni = {path = "../../ports/arcore_jni"}
diff --git a/components/canvas/webgl_thread.rs b/components/canvas/webgl_thread.rs
index f01380bfbe..1aae8655aa 100644
--- a/components/canvas/webgl_thread.rs
+++ b/components/canvas/webgl_thread.rs
@@ -17,6 +17,7 @@ use canvas_traits::webgl::ProgramLinkInfo;
 use canvas_traits::webgl::SwapChainId;
 use canvas_traits::webgl::TexDataType;
 use canvas_traits::webgl::TexFormat;
+use canvas_traits::webgl::WebARCommand;
 use canvas_traits::webgl::WebGLBufferId;
 use canvas_traits::webgl::WebGLChan;
 use canvas_traits::webgl::WebGLCommand;
@@ -326,6 +327,93 @@ impl WebGLThread {
                 self.remove_webgl_context(ctx_id);
             },
             WebGLMsg::WebGLCommand(ctx_id, command, backtrace) => {
+                match &command {
+                    WebGLCommand::DrawBackground => {
+                        ::arcore_jni::log("webgl_thread::WebGLCommand::DrawBackground");
+                        self.handle_webar_command(ctx_id, WebARCommand::OnDraw);
+                    }
+                    WebGLCommand::GetProjectMatrix(result_sender) => {
+                        ::arcore_jni::log("webgl_thread::WebGLCommand::GetProjectMatrix");
+
+                        let arcore = &self.cached_context_info.get_mut(&ctx_id).unwrap().arcore;
+                        let mut vector = Vec::with_capacity(16);
+                        vector.extend_from_slice(&arcore.proj_mat4x4);
+                        result_sender.send(vector);
+                    }
+                    WebGLCommand::GetViewMatrix(result_sender) => {
+                        ::arcore_jni::log("webgl_thread::WebGLCommand::GetViewMatrix");
+
+                        let arcore = &self.cached_context_info.get_mut(&ctx_id).unwrap().arcore;
+                        let mut vector = Vec::with_capacity(16);
+                        vector.extend_from_slice(&arcore.view_mat4x4);
+                        result_sender.send(vector);
+                    }
+//                    WebGLCommand::ProjectViewMatrix(location) => {
+//                        ::arcore_jni::log("webgl_thread::WebGLCommand::ProjectViewMatrix");
+//
+//                        let info = self.cached_context_info.get_mut(&ctx_id).unwrap();
+//                        let arcore = &info.arcore;
+////                        let location = arcore.uniform_mvp_mat_;
+//                        ::arcore_jni::log(&format!("webgl_thread::WebGLCommand::ProjectViewMatrix  location = {}", location));
+//                        ::arcore_jni::log(&format!("webgl_thread::WebGLCommand::ProjectViewMatrix  mvp = {:?}", &arcore.pv));
+//                        if location == -1 {
+//                            ()
+//                        } else {
+//                            let data = Self::make_current_if_needed(
+//                                &self.device,
+//                                ctx_id,
+//                                &self.contexts,
+//                                &mut self.bound_context_id,
+//                            ).expect("WebGLContext not found");
+//                            data.gl.uniform_matrix_4fv(location, false, &arcore.pv);
+//                        };
+//                    }
+//                    WebGLCommand::ProjectMatrix(*location) => {
+//                        ::arcore_jni::log("webgl_thread::WebGLCommand::ProjectMatrix");
+//
+//                        let info = self.cached_context_info.get_mut(&ctx_id).unwrap();
+//                        let arcore = &info.arcore;
+//
+////                        let location = &*arcore.uniform_mvp_mat_ as i32;
+//                        ::arcore_jni::log(&format!("webgl_thread::WebGLCommand::ProjectMatrix  location = {}", location));
+//                        ::arcore_jni::log(&format!("webgl_thread::WebGLCommand::ProjectMatrix  mvp = {:?}", &arcore.proj_mat4x4));
+//                        if location == -1 {
+//                            ()
+//                        } else {
+//                            let data = Self::make_current_if_needed(
+//                                &self.device,
+//                                ctx_id,
+//                                &self.contexts,
+//                                &mut self.bound_context_id,
+//                            ).expect("WebGLContext not found");
+//                            data.gl.uniform_matrix_4fv(location, false, &arcore.proj_mat4x4);
+//                        };
+//                    }
+//                    WebGLCommand::ViewMatrix(*location) => {
+//                        ::arcore_jni::log("webgl_thread::WebGLCommand::ViewMatrix");
+//
+//                        let info = self.cached_context_info.get_mut(&ctx_id).unwrap();
+//                        let arcore = &info.arcore;
+//                        if let Some(ctx) = Self::make_current_if_needed(&self.device, ctx_id, &self.contexts, &mut self.bound_context_id) {
+//                            //                            let location = arcore.uniform_mvp_mat_;
+//                            ::arcore_jni::log(&format!("webgl_thread::WebGLCommand::ViewMatrix  location = {}", location));
+//                            ::arcore_jni::log(&format!("webgl_thread::WebGLCommand::ViewMatrix  mvp = {:?}", &arcore.view_mat4x4));
+//                            if location == -1 {
+//                                ()
+//                            } else {
+//                                let data = Self::make_current_if_needed(
+//                                    &self.device,
+//                                    ctx_id,
+//                                    &self.contexts,
+//                                    &mut self.bound_context_id,
+//                                ).expect("WebGLContext not found");
+//                                data.gl.uniform_matrix_4fv(location, false, &arcore.view_mat4x4);
+//                            };
+//                        }
+//                    }
+
+                    _ => {}
+                }
                 self.handle_webgl_command(ctx_id, command, backtrace);
             },
             WebGLMsg::WebVRCommand(ctx_id, command) => {
@@ -406,6 +494,26 @@ impl WebGLThread {
         }
     }
 
+    fn handle_webar_command(&mut self, ctx_id: WebGLContextId, command: WebARCommand) {
+        let data = Self::make_current_if_needed(
+            &self.device,
+            ctx_id,
+            &self.contexts,
+            &mut self.bound_context_id,
+        ).expect("WebGLContext not found");
+
+        let arcore = &mut self.cached_context_info.get_mut(&ctx_id).unwrap().arcore;
+
+        match command {
+            WebARCommand::OnDisplayChanged(display_rotation, width, height) => {
+                arcore.on_display_changed(&*data.gl, display_rotation, width, height);
+            }
+            WebARCommand::OnDraw => {
+                arcore.on_draw(&*data.gl);
+            }
+        }
+    }
+
     /// Handles a WebVRCommand for a specific WebGLContext
     fn handle_webvr_command(&mut self, _context_id: WebGLContextId, _command: WebVRCommand) {
         // TODO(pcwalton): Reenable.
@@ -562,8 +670,17 @@ impl WebGLThread {
             texture_target,
         );
 
+        let mut arcore = ::arcore_jni::init_arcore();
+        let data = Self::make_current_if_needed(
+            &self.device,
+            id,
+            &self.contexts,
+            &mut self.bound_context_id,
+        ).expect("WebGLContext not found");
+        &arcore.on_display_changed(&data.gl, 0, 1080, 1920);
+
         self.cached_context_info
-            .insert(id, WebGLContextInfo { image_key });
+            .insert(id, WebGLContextInfo { image_key, arcore });
 
         Ok((id, limits))
     }
@@ -1000,6 +1117,7 @@ impl Drop for WebGLThread {
 struct WebGLContextInfo {
     /// Currently used WebRender image key.
     image_key: webrender_api::ImageKey,
+    arcore: ::arcore_jni::ArCore,
 }
 
 // TODO(pcwalton): Add `GL_TEXTURE_EXTERNAL_OES`?
@@ -1038,6 +1156,13 @@ impl WebGLImpl {
         debug_assert_eq!(gl.get_error(), gl::NO_ERROR);
 
         match command {
+            WebGLCommand::DrawBackground => (),
+            WebGLCommand::ProjectViewMatrix(_) => (),
+            WebGLCommand::ProjectMatrix(_) => (),
+            WebGLCommand::ViewMatrix(_) => (),
+            WebGLCommand::GetProjectMatrix(_) => (),
+            WebGLCommand::GetViewMatrix(_) => (),
+
             WebGLCommand::GetContextAttributes(ref sender) => sender.send(*attributes).unwrap(),
             WebGLCommand::ActiveTexture(target) => gl.active_texture(target),
             WebGLCommand::AttachShader(program_id, shader_id) => {
diff --git a/components/canvas_traits/webgl.rs b/components/canvas_traits/webgl.rs
index 22e47ad9bb..c5349cb917 100644
--- a/components/canvas_traits/webgl.rs
+++ b/components/canvas_traits/webgl.rs
@@ -251,9 +251,22 @@ impl<T> Deref for TruncatedDebug<T> {
     }
 }
 
+#[derive(Clone, Deserialize, Serialize)]
+pub enum WebARCommand {
+    OnDisplayChanged(i32, i32, i32),
+    OnDraw,
+}
+
 /// WebGL Commands for a specific WebGLContext
 #[derive(Debug, Deserialize, Serialize)]
 pub enum WebGLCommand {
+    DrawBackground,
+    ProjectViewMatrix(i32),
+    ProjectMatrix(i32),
+    ViewMatrix(i32),
+    GetProjectMatrix(WebGLSender<Vec<f32>>),
+    GetViewMatrix(WebGLSender<Vec<f32>>),
+
     GetContextAttributes(WebGLSender<GLContextAttributes>),
     ActiveTexture(u32),
     BlendColor(f32, f32, f32, f32),
diff --git a/components/script/dom/webgl2renderingcontext.rs b/components/script/dom/webgl2renderingcontext.rs
index 9f0bfcd89c..d2d49db752 100644
--- a/components/script/dom/webgl2renderingcontext.rs
+++ b/components/script/dom/webgl2renderingcontext.rs
@@ -3611,6 +3611,34 @@ impl WebGL2RenderingContextMethods for WebGL2RenderingContext {
             None => self.base.webgl_error(InvalidOperation),
         }
     }
+
+
+    fn DrawBackground(&self) {
+        self.base.DrawBackground();
+    }
+
+//    fn ProjectViewMatrix(&self, location: Option<&WebGLUniformLocation>) {
+//        self.base.ProjectViewMatrix(location);
+//    }
+//
+//    fn ProjectMatrix(&self, location: Option<&WebGLUniformLocation>) {
+//        self.base.ProjectMatrix(location);
+//    }
+//
+//    fn ViewMatrix(&self, location: Option<&WebGLUniformLocation>) {
+//        self.base.ViewMatrix(location);
+//    }
+
+    #[allow(unsafe_code)]
+    fn GetProjectMatrix(&self, cx: crate::script_runtime::JSContext) -> NonNull<JSObject> {
+        self.base.GetProjectMatrix(cx)
+    }
+
+    #[allow(unsafe_code)]
+    fn GetViewMatrix(&self, cx: crate::script_runtime::JSContext) -> NonNull<JSObject> {
+        self.base.GetViewMatrix(cx)
+    }
+
 }
 
 impl LayoutCanvasWebGLRenderingContextHelpers for LayoutDom<WebGL2RenderingContext> {
diff --git a/components/script/dom/webglrenderingcontext.rs b/components/script/dom/webglrenderingcontext.rs
index ca5c08b25e..280bea0645 100644
--- a/components/script/dom/webglrenderingcontext.rs
+++ b/components/script/dom/webglrenderingcontext.rs
@@ -145,6 +145,16 @@ bitflags! {
     }
 }
 
+
+#[allow(unsafe_code)]
+pub fn create_typed_array(cx: crate::script_runtime::JSContext, src: &[f32], dst: &::js::jsapi::Heap<*mut JSObject>) {
+    rooted!(in (*cx) let mut array = ptr::null_mut::<JSObject>());
+    unsafe {
+        let _ = Float32Array::create(*cx, CreateWith::Slice(src), array.handle_mut());
+    }
+    (*dst).set(array.get());
+}
+
 #[dom_struct]
 pub struct WebGLRenderingContext {
     reflector_: Reflector,
@@ -4301,6 +4311,51 @@ impl WebGLRenderingContextMethods for WebGLRenderingContext {
         p.resolve_native(&());
         p
     }
+
+
+    fn DrawBackground(&self) {
+        self.send_command(WebGLCommand::DrawBackground);
+    }
+
+//    fn ProjectViewMatrix(&self, location: Option<&WebGLUniformLocation>) {
+//        self.send_command(WebGLCommand::ProjectViewMatrix(location.unwrap().id()));
+//    }
+//
+//    fn ProjectMatrix(&self, location: Option<&WebGLUniformLocation>) {
+//        self.send_command(WebGLCommand::ProjectMatrix(location.unwrap().id()));
+//    }
+//
+//    fn ViewMatrix(&self, location: Option<&WebGLUniformLocation>) {
+//        self.send_command(WebGLCommand::ViewMatrix(location.unwrap().id()));
+//    }
+
+    #[allow(unsafe_code)]
+    fn GetProjectMatrix(&self, _cx: crate::script_runtime::JSContext) -> NonNull<JSObject> {
+
+        let (sender, receiver) = webgl_channel().unwrap();
+        self.send_command(WebGLCommand::GetProjectMatrix(sender));
+
+        let proj: ::js::jsapi::Heap<*mut JSObject> = ::js::jsapi::Heap::default();
+        let result = receiver.recv().unwrap();
+
+        let cx = self.global().get_cx();
+        create_typed_array(cx, &result, &proj);
+        unsafe { NonNull::new_unchecked(proj.get()) }
+    }
+
+    #[allow(unsafe_code)]
+    fn GetViewMatrix(&self, _cx: crate::script_runtime::JSContext) -> NonNull<JSObject> {
+
+        let (sender, receiver) = webgl_channel().unwrap();
+        self.send_command(WebGLCommand::GetViewMatrix(sender));
+
+        let proj: ::js::jsapi::Heap<*mut JSObject> = ::js::jsapi::Heap::default();
+        let result = receiver.recv().unwrap();
+
+        let cx = self.global().get_cx();
+        create_typed_array(cx, &result, &proj);
+        unsafe { NonNull::new_unchecked(proj.get()) }
+    }
 }
 
 pub trait LayoutCanvasWebGLRenderingContextHelpers {
diff --git a/components/script/dom/webidls/WebGLRenderingContext.webidl b/components/script/dom/webidls/WebGLRenderingContext.webidl
index a9af389b04..7aeade0ca6 100644
--- a/components/script/dom/webidls/WebGLRenderingContext.webidl
+++ b/components/script/dom/webidls/WebGLRenderingContext.webidl
@@ -692,6 +692,15 @@ interface mixin WebGLRenderingContextBase
                              GLboolean normalized, GLsizei stride, GLintptr offset);
 
     void viewport(GLint x, GLint y, GLsizei width, GLsizei height);
+
+        //*********************   AR    ******************************
+                void drawBackground();
+        //        void projectViewMatrix(WebGLUniformLocation? location);
+        //        void projectMatrix(WebGLUniformLocation? location);
+        //        void viewMatrix(WebGLUniformLocation? location);
+                Float32Array getProjectMatrix();
+                Float32Array getViewMatrix();
+        //*************************************************************
 };
 
 [Exposed=Window]
diff --git a/support/android/apk/servoapp/build.gradle b/support/android/apk/servoapp/build.gradle
index 6b440e7b2c..3828b762fb 100644
--- a/support/android/apk/servoapp/build.gradle
+++ b/support/android/apk/servoapp/build.gradle
@@ -150,4 +150,9 @@ dependencies {
     } else {
       implementation project(':servoview')
     }
+    // ARCore library
+    implementation 'com.google.ar:core:1.5.0'
+
+    implementation 'com.android.support:appcompat-v7:27.1.1'
+    implementation 'com.android.support:design:27.1.1'
 }
diff --git a/support/android/apk/servoapp/src/main/AndroidManifest.xml b/support/android/apk/servoapp/src/main/AndroidManifest.xml
index 71db56c53a..541efdd148 100644
--- a/support/android/apk/servoapp/src/main/AndroidManifest.xml
+++ b/support/android/apk/servoapp/src/main/AndroidManifest.xml
@@ -5,13 +5,21 @@
 
     <uses-feature android:glEsVersion="0x00030000" android:required="true" />
     <uses-feature android:name="android.hardware.bluetooth_le" android:required="true"/>
+    <uses-permission android:name="android.permission.CAMERA"/>
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.BLUETOOTH" />
     <uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/>
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
 
+    <uses-sdk android:minSdkVersion="14" />
+    <!-- This tag indicates that this application requires ARCore.  This results in the application
+       only being visible in the Google Play Store on devices that support ARCore. -->
+    <uses-feature android:name="android.hardware.camera.ar" android:required="true"/>
+    <uses-feature android:glEsVersion="0x00020000" android:required="true" />
+
     <application android:label="Servo" android:icon="@mipmap/servo">
+        <meta-data android:name="com.google.ar.core" android:value="required" />
         <activity android:name=".MainActivity"
                 android:label="Servo"
                 android:configChanges="density|keyboardHidden|navigation|orientation|screenSize|uiMode">
diff --git a/support/android/apk/servoapp/src/main/java/org/mozilla/servo/CameraPermissionHelper.java b/support/android/apk/servoapp/src/main/java/org/mozilla/servo/CameraPermissionHelper.java
new file mode 100755
index 0000000000..f6b1c7881c
--- /dev/null
+++ b/support/android/apk/servoapp/src/main/java/org/mozilla/servo/CameraPermissionHelper.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2017 Google Inc. All Rights Reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.mozilla.servo;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.provider.Settings;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.content.ContextCompat;
+
+/** Helper to ask camera permission. */
+public class CameraPermissionHelper {
+  private static final String CAMERA_PERMISSION = Manifest.permission.CAMERA;
+  private static final int CAMERA_PERMISSION_CODE = 0;
+
+  /** Check to see we have the necessary permissions for this app. */
+  public static boolean hasCameraPermission(Activity activity) {
+    return ContextCompat.checkSelfPermission(activity, CAMERA_PERMISSION)
+        == PackageManager.PERMISSION_GRANTED;
+  }
+
+  /** Check to see we have the necessary permissions for this app, and ask for them if we don't. */
+  public static void requestCameraPermission(Activity activity) {
+    ActivityCompat.requestPermissions(
+        activity, new String[] {CAMERA_PERMISSION}, CAMERA_PERMISSION_CODE);
+  }
+
+  /** Check to see if we need to show the rationale for this permission. */
+  public static boolean shouldShowRequestPermissionRationale(Activity activity) {
+    return ActivityCompat.shouldShowRequestPermissionRationale(activity, CAMERA_PERMISSION);
+  }
+
+  /** Launch Application Setting to grant permission. */
+  public static void launchPermissionSettings(Activity activity) {
+    Intent intent = new Intent();
+    intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
+    intent.setData(Uri.fromParts("package", activity.getPackageName(), null));
+    activity.startActivity(intent);
+  }
+}
diff --git a/support/android/apk/servoapp/src/main/java/org/mozilla/servo/MainActivity.java b/support/android/apk/servoapp/src/main/java/org/mozilla/servo/MainActivity.java
index 1e1c9dbabe..c32581db4f 100644
--- a/support/android/apk/servoapp/src/main/java/org/mozilla/servo/MainActivity.java
+++ b/support/android/apk/servoapp/src/main/java/org/mozilla/servo/MainActivity.java
@@ -216,6 +216,12 @@ public class MainActivity extends Activity implements Servo.Client {
     public void onResume() {
         mServoView.onResume();
         super.onResume();
+        // ARCore requires camera permissions to operate. If we did not yet obtain runtime
+        // permission on Android M and above, now is a good time to ask the user for it.
+        if (!CameraPermissionHelper.hasCameraPermission(this)) {
+            CameraPermissionHelper.requestCameraPermission(this);
+            return;
+        }
     }
 
     @Override
-- 
2.16.2

